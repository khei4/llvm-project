; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 3
; RUN: opt < %s  -passes=memcpyopt -S | FileCheck %s

%struct.Foo = type { i32, i32, i32 }

declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #0

declare i32 @use_nocapture(ptr nocapture)

; Do not crash if the different block user comes first.
define void @crash_store_comesbefore(i1 %b) {
; CHECK-LABEL: define void @crash_store_comesbefore
; CHECK-SAME: (i1 [[B:%.*]]) {
; CHECK-NEXT:    [[DEST:%.*]] = alloca [[STRUCT_FOO:%.*]], align 8
; CHECK-NEXT:    [[SRC:%.*]] = alloca [[STRUCT_FOO]], align 8
; CHECK-NEXT:    store i32 0, ptr [[DEST]], align 4
; CHECK-NEXT:    br i1 [[B]], label [[THEN:%.*]], label [[ELSE:%.*]]
; CHECK:       then:
; CHECK-NEXT:    [[T:%.*]] = call i32 @use_nocapture(ptr nocapture noundef [[SRC]])
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr [[DEST]], ptr [[SRC]], i64 12, i1 false)
; CHECK-NEXT:    [[T3:%.*]] = call i32 @use_nocapture(ptr nocapture noundef [[SRC]])
; CHECK-NEXT:    [[T4:%.*]] = call i32 @use_nocapture(ptr nocapture noundef [[DEST]])
; CHECK-NEXT:    br label [[ELSE]]
; CHECK:       else:
; CHECK-NEXT:    ret void
;
  %dest = alloca %struct.Foo, align 8
  %src = alloca %struct.Foo, align 8
  store i32 0, ptr %dest, align 4
  br i1 %b, label %then, label %else

then:                                             ; preds = %entry
  %t = call i32 @use_nocapture(ptr nocapture noundef %src)
  call void @llvm.memcpy.p0.p0.i64(ptr %dest, ptr %src, i64 12, i1 false)
  %t3 = call i32 @use_nocapture(ptr nocapture noundef %src)
  %t4 = call i32 @use_nocapture(ptr nocapture noundef %dest)
  br label %else

else:                                             ; preds = %then, %entry
  ret void

  uselistorder ptr %dest, { 1, 2, 0 }
}

attributes #0 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
